package gitlab

import (
	"fmt"
	"sort"
	"strings"
	"time"

	gitlab "gitlab.com/gitlab-org/api/client-go"

	"github.com/edelwud/terraci/internal/policy"
)

const (
	// CommentMarker is used to identify terraci comments for updates
	CommentMarker = "<!-- terraci-plan-comment -->"
	// maxErrorLength is the maximum length for error messages in summary
	maxErrorLength = 50
	// maxDetailsLength is the maximum length for expandable details
	maxDetailsLength = 10000
	// Cost formatting thresholds
	minCostThreshold      = 0.01
	thousandCostThreshold = 1000
)

// ModulePlan represents terraform plan output for a single module
type ModulePlan struct {
	ModuleID          string
	ModulePath        string
	Service           string
	Environment       string
	Region            string
	Module            string
	Status            PlanStatus
	Summary           string // Compact summary e.g., "+2 ~1 -1"
	StructuredDetails string // Structured resource list by action (markdown)
	RawPlanOutput     string // Filtered raw plan output (diff only)
	Error             string // Error message if plan failed
	Duration          time.Duration
	// Cost estimation fields
	CostBefore float64 // Monthly cost before changes (USD)
	CostAfter  float64 // Monthly cost after changes (USD)
	CostDiff   float64 // Cost difference (after - before)
	HasCost    bool    // True if cost was calculated
}

// PlanStatus represents the status of a terraform plan
type PlanStatus string

const (
	PlanStatusPending   PlanStatus = "pending"
	PlanStatusRunning   PlanStatus = "running"
	PlanStatusSuccess   PlanStatus = "success"
	PlanStatusNoChanges PlanStatus = "no_changes"
	PlanStatusChanges   PlanStatus = "changes"
	PlanStatusFailed    PlanStatus = "failed"
)

// CommentData contains all data needed to render an MR comment
type CommentData struct {
	Plans         []ModulePlan
	PolicySummary *policy.Summary
	PipelineURL   string
	PipelineID    string
	CommitSHA     string
	GeneratedAt   time.Time
	TotalModules  int
}

// CommentRenderer renders MR comments
type CommentRenderer struct{}

// NewCommentRenderer creates a new comment renderer
func NewCommentRenderer() *CommentRenderer {
	return &CommentRenderer{}
}

// Render generates the MR comment body
func (r *CommentRenderer) Render(data *CommentData) string {
	var sb strings.Builder

	// Marker for identifying our comments
	sb.WriteString(CommentMarker)
	sb.WriteString("\n\n")

	// Header
	sb.WriteString("## üèóÔ∏è Terraform Plan Summary\n\n")

	// Stats summary
	stats := r.calculateStats(data.Plans)
	sb.WriteString(r.renderStats(stats))
	sb.WriteString("\n\n")

	// Policy check section (if available)
	if data.PolicySummary != nil {
		sb.WriteString(r.renderPolicySection(data.PolicySummary))
		sb.WriteString("\n")
	}

	// Group plans by environment
	byEnv := r.groupByEnvironment(data.Plans)

	// Render each environment
	envOrder := r.sortedKeys(byEnv)
	for _, env := range envOrder {
		plans := byEnv[env]
		sb.WriteString(r.renderEnvironmentSection(env, plans))
		sb.WriteString("\n")
	}

	// Footer
	sb.WriteString("\n---\n")
	sb.WriteString(fmt.Sprintf("üìã Generated by [terraci](https://github.com/edelwud/terraci) at %s",
		data.GeneratedAt.Format("2006-01-02 15:04:05 UTC")))

	if data.PipelineURL != "" {
		sb.WriteString(fmt.Sprintf(" | [Pipeline #%s](%s)", data.PipelineID, data.PipelineURL))
	}

	if data.CommitSHA != "" {
		sb.WriteString(fmt.Sprintf(" | Commit: `%s`", data.CommitSHA[:8]))
	}

	sb.WriteString("\n")

	return sb.String()
}

// renderPolicySection renders the policy check results section
func (r *CommentRenderer) renderPolicySection(summary *policy.Summary) string {
	var sb strings.Builder

	// Section header with status icon
	icon := "‚úÖ"
	if summary.HasFailures() {
		icon = "‚ùå"
	} else if summary.HasWarnings() {
		icon = "‚ö†Ô∏è"
	}

	sb.WriteString(fmt.Sprintf("### %s Policy Check\n\n", icon))

	// Stats
	var parts []string
	if summary.PassedModules > 0 {
		parts = append(parts, fmt.Sprintf("‚úÖ **%d** passed", summary.PassedModules))
	}
	if summary.WarnedModules > 0 {
		parts = append(parts, fmt.Sprintf("‚ö†Ô∏è **%d** warned", summary.WarnedModules))
	}
	if summary.FailedModules > 0 {
		parts = append(parts, fmt.Sprintf("‚ùå **%d** failed", summary.FailedModules))
	}

	if len(parts) > 0 {
		sb.WriteString(fmt.Sprintf("**%d** modules checked: %s\n\n", summary.TotalModules, strings.Join(parts, " | ")))
	}

	// Show failures
	if summary.TotalFailures > 0 {
		sb.WriteString("<details>\n")
		sb.WriteString(fmt.Sprintf("<summary>‚ùå Failures (%d)</summary>\n\n", summary.TotalFailures))

		for _, result := range summary.Results {
			if len(result.Failures) == 0 {
				continue
			}
			sb.WriteString(fmt.Sprintf("**%s:**\n", result.Module))
			for _, f := range result.Failures {
				sb.WriteString(fmt.Sprintf("- `%s`: %s\n", f.Namespace, f.Message))
			}
			sb.WriteString("\n")
		}

		sb.WriteString("</details>\n\n")
	}

	// Show warnings
	if summary.TotalWarnings > 0 {
		sb.WriteString("<details>\n")
		sb.WriteString(fmt.Sprintf("<summary>‚ö†Ô∏è Warnings (%d)</summary>\n\n", summary.TotalWarnings))

		for _, result := range summary.Results {
			if len(result.Warnings) == 0 {
				continue
			}
			sb.WriteString(fmt.Sprintf("**%s:**\n", result.Module))
			for _, w := range result.Warnings {
				sb.WriteString(fmt.Sprintf("- `%s`: %s\n", w.Namespace, w.Message))
			}
			sb.WriteString("\n")
		}

		sb.WriteString("</details>\n\n")
	}

	return sb.String()
}

type planStats struct {
	Total     int
	Success   int
	NoChanges int
	Changes   int
	Failed    int
	Pending   int
	Running   int
}

func (r *CommentRenderer) calculateStats(plans []ModulePlan) planStats {
	var stats planStats
	stats.Total = len(plans)

	for i := range plans {
		switch plans[i].Status {
		case PlanStatusSuccess, PlanStatusNoChanges:
			stats.NoChanges++
		case PlanStatusChanges:
			stats.Changes++
		case PlanStatusFailed:
			stats.Failed++
		case PlanStatusPending:
			stats.Pending++
		case PlanStatusRunning:
			stats.Running++
		}
	}
	stats.Success = stats.NoChanges + stats.Changes

	return stats
}

func (r *CommentRenderer) renderStats(stats planStats) string {
	var parts []string

	if stats.Changes > 0 {
		parts = append(parts, fmt.Sprintf("üîÑ **%d** with changes", stats.Changes))
	}
	if stats.NoChanges > 0 {
		parts = append(parts, fmt.Sprintf("‚úÖ **%d** no changes", stats.NoChanges))
	}
	if stats.Failed > 0 {
		parts = append(parts, fmt.Sprintf("‚ùå **%d** failed", stats.Failed))
	}
	if stats.Running > 0 {
		parts = append(parts, fmt.Sprintf("üîÑ **%d** running", stats.Running))
	}
	if stats.Pending > 0 {
		parts = append(parts, fmt.Sprintf("‚è≥ **%d** pending", stats.Pending))
	}

	if len(parts) == 0 {
		return fmt.Sprintf("**%d** modules analyzed", stats.Total)
	}

	return fmt.Sprintf("**%d** modules: %s", stats.Total, strings.Join(parts, " | "))
}

func (r *CommentRenderer) groupByEnvironment(plans []ModulePlan) map[string][]ModulePlan {
	result := make(map[string][]ModulePlan)
	for i := range plans {
		env := plans[i].Environment
		if env == "" {
			env = "default"
		}
		result[env] = append(result[env], plans[i])
	}
	return result
}

func (r *CommentRenderer) sortedKeys(m map[string][]ModulePlan) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

func (r *CommentRenderer) renderEnvironmentSection(env string, plans []ModulePlan) string {
	var sb strings.Builder

	// Environment header
	sb.WriteString(fmt.Sprintf("### üì¶ Environment: `%s`\n\n", env))

	// Sort plans by module ID
	sort.Slice(plans, func(i, j int) bool {
		return plans[i].ModuleID < plans[j].ModuleID
	})

	// Check if any plan has cost data
	hasCostData := false
	for i := range plans {
		if plans[i].HasCost {
			hasCostData = true
			break
		}
	}

	// Table header (with or without Cost column)
	if hasCostData {
		sb.WriteString("| Status | Module | Summary | Cost |\n")
		sb.WriteString("|:------:|--------|--------|------|\n")
	} else {
		sb.WriteString("| Status | Module | Summary |\n")
		sb.WriteString("|:------:|--------|--------|\n")
	}

	for i := range plans {
		sb.WriteString(r.renderPlanRow(&plans[i], hasCostData))
	}

	// Expandable details for modules with changes or errors
	for i := range plans {
		hasDetails := plans[i].StructuredDetails != "" || plans[i].RawPlanOutput != "" || plans[i].Error != ""
		if hasDetails && (plans[i].Status == PlanStatusChanges || plans[i].Status == PlanStatusFailed) {
			sb.WriteString(r.renderExpandableDetails(&plans[i]))
		}
	}

	return sb.String()
}

func (r *CommentRenderer) renderPlanRow(p *ModulePlan, includeCost bool) string {
	status := r.statusIcon(p.Status)
	module := fmt.Sprintf("`%s`", p.ModuleID)

	summary := p.Summary
	if p.Error != "" {
		summary = fmt.Sprintf("‚ö†Ô∏è %s", truncate(p.Error, maxErrorLength))
	}
	if summary == "" {
		summary = "-"
	}

	if !includeCost {
		return fmt.Sprintf("| %s | %s | %s |\n", status, module, summary)
	}

	// Format cost column: "$X ‚Üí +$Y ‚Üí $Z" or just diff if no change in base
	cost := formatCostCell(p)
	return fmt.Sprintf("| %s | %s | %s | %s |\n", status, module, summary, cost)
}

// formatCostCell formats the cost cell for a module plan
func formatCostCell(p *ModulePlan) string {
	if !p.HasCost {
		return "-"
	}

	// Format: "$before ‚Üí +$diff ‚Üí $after" or simpler formats
	if p.CostDiff == 0 {
		return formatMonthlyCost(p.CostAfter)
	}

	// Show full breakdown: before ‚Üí diff ‚Üí after
	before := formatMonthlyCost(p.CostBefore)
	after := formatMonthlyCost(p.CostAfter)
	diff := formatCostDiff(p.CostDiff)

	return fmt.Sprintf("%s %s ‚Üí %s", before, diff, after)
}

// formatMonthlyCost formats a monthly cost value
func formatMonthlyCost(cost float64) string {
	if cost == 0 {
		return "$0"
	}
	if cost < minCostThreshold {
		return "<$0.01"
	}
	if cost >= thousandCostThreshold {
		return fmt.Sprintf("$%.0f", cost)
	}
	if cost >= 1 {
		return fmt.Sprintf("$%.2f", cost)
	}
	return fmt.Sprintf("$%.4f", cost)
}

// formatCostDiff formats a cost difference with sign
func formatCostDiff(diff float64) string {
	if diff == 0 {
		return "$0"
	}
	if diff > 0 {
		if diff >= thousandCostThreshold {
			return fmt.Sprintf("+$%.0f", diff)
		}
		if diff >= 1 {
			return fmt.Sprintf("+$%.2f", diff)
		}
		return fmt.Sprintf("+$%.4f", diff)
	}
	// Negative diff
	diff = -diff
	if diff >= thousandCostThreshold {
		return fmt.Sprintf("-$%.0f", diff)
	}
	if diff >= 1 {
		return fmt.Sprintf("-$%.2f", diff)
	}
	return fmt.Sprintf("-$%.4f", diff)
}

func (r *CommentRenderer) statusIcon(status PlanStatus) string {
	switch status {
	case PlanStatusSuccess, PlanStatusNoChanges:
		return "‚úÖ"
	case PlanStatusChanges:
		return "üîÑ"
	case PlanStatusFailed:
		return "‚ùå"
	case PlanStatusPending:
		return "‚è≥"
	case PlanStatusRunning:
		return "üîÑ"
	default:
		return "‚ùì"
	}
}

func (r *CommentRenderer) renderExpandableDetails(p *ModulePlan) string {
	var sb strings.Builder

	// Title with summary
	title := fmt.Sprintf("üìã %s", p.ModuleID)
	if p.Summary != "" && p.Summary != "No changes" {
		title = fmt.Sprintf("üìã %s (%s)", p.ModuleID, p.Summary)
	}
	if p.Status == PlanStatusFailed {
		title = fmt.Sprintf("‚ùå %s", p.ModuleID)
	}

	sb.WriteString(fmt.Sprintf("\n<details>\n<summary>%s</summary>\n\n", title))

	// Structured resource list (if available)
	if p.StructuredDetails != "" {
		sb.WriteString(p.StructuredDetails)
		sb.WriteString("\n\n")
	}

	// Raw plan output with diff highlighting
	if p.RawPlanOutput != "" {
		sb.WriteString("<details>\n<summary>Full plan output</summary>\n\n")
		sb.WriteString("```diff\n")
		sb.WriteString(truncate(p.RawPlanOutput, maxDetailsLength))
		sb.WriteString("\n```\n")
		sb.WriteString("</details>\n")
	}

	sb.WriteString("</details>\n")

	return sb.String()
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

// FindTerraCIComment finds an existing terraci comment in the notes
func FindTerraCIComment(notes []*gitlab.Note) *gitlab.Note {
	for _, note := range notes {
		if strings.Contains(note.Body, CommentMarker) {
			return note
		}
	}
	return nil
}
