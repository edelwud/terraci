package gitlab

import (
	"fmt"
	"sort"
	"strings"
	"time"

	gitlab "gitlab.com/gitlab-org/api/client-go"
)

const (
	// CommentMarker is used to identify terraci comments for updates
	CommentMarker = "<!-- terraci-plan-comment -->"
	// maxErrorLength is the maximum length for error messages in summary
	maxErrorLength = 50
	// maxDetailsLength is the maximum length for expandable details
	maxDetailsLength = 10000
)

// ModulePlan represents terraform plan output for a single module
type ModulePlan struct {
	ModuleID    string
	ModulePath  string
	Service     string
	Environment string
	Region      string
	Module      string
	Status      PlanStatus
	Summary     string // e.g., "Plan: 2 to add, 1 to change, 0 to destroy"
	Details     string // Full plan output (optional, for expandable section)
	Error       string // Error message if plan failed
	Duration    time.Duration
}

// PlanStatus represents the status of a terraform plan
type PlanStatus string

const (
	PlanStatusPending   PlanStatus = "pending"
	PlanStatusRunning   PlanStatus = "running"
	PlanStatusSuccess   PlanStatus = "success"
	PlanStatusNoChanges PlanStatus = "no_changes"
	PlanStatusChanges   PlanStatus = "changes"
	PlanStatusFailed    PlanStatus = "failed"
)

// CommentData contains all data needed to render an MR comment
type CommentData struct {
	Plans        []ModulePlan
	PipelineURL  string
	PipelineID   string
	CommitSHA    string
	GeneratedAt  time.Time
	TotalModules int
}

// CommentRenderer renders MR comments
type CommentRenderer struct{}

// NewCommentRenderer creates a new comment renderer
func NewCommentRenderer() *CommentRenderer {
	return &CommentRenderer{}
}

// Render generates the MR comment body
func (r *CommentRenderer) Render(data *CommentData) string {
	var sb strings.Builder

	// Marker for identifying our comments
	sb.WriteString(CommentMarker)
	sb.WriteString("\n\n")

	// Header
	sb.WriteString("## üèóÔ∏è Terraform Plan Summary\n\n")

	// Stats summary
	stats := r.calculateStats(data.Plans)
	sb.WriteString(r.renderStats(stats))
	sb.WriteString("\n\n")

	// Group plans by environment
	byEnv := r.groupByEnvironment(data.Plans)

	// Render each environment
	envOrder := r.sortedKeys(byEnv)
	for _, env := range envOrder {
		plans := byEnv[env]
		sb.WriteString(r.renderEnvironmentSection(env, plans))
		sb.WriteString("\n")
	}

	// Footer
	sb.WriteString("\n---\n")
	sb.WriteString(fmt.Sprintf("üìã Generated by [terraci](https://github.com/edelwud/terraci) at %s",
		data.GeneratedAt.Format("2006-01-02 15:04:05 UTC")))

	if data.PipelineURL != "" {
		sb.WriteString(fmt.Sprintf(" | [Pipeline #%s](%s)", data.PipelineID, data.PipelineURL))
	}

	if data.CommitSHA != "" {
		sb.WriteString(fmt.Sprintf(" | Commit: `%s`", data.CommitSHA[:8]))
	}

	sb.WriteString("\n")

	return sb.String()
}

type planStats struct {
	Total     int
	Success   int
	NoChanges int
	Changes   int
	Failed    int
	Pending   int
	Running   int
}

func (r *CommentRenderer) calculateStats(plans []ModulePlan) planStats {
	var stats planStats
	stats.Total = len(plans)

	for i := range plans {
		switch plans[i].Status {
		case PlanStatusSuccess, PlanStatusNoChanges:
			stats.NoChanges++
		case PlanStatusChanges:
			stats.Changes++
		case PlanStatusFailed:
			stats.Failed++
		case PlanStatusPending:
			stats.Pending++
		case PlanStatusRunning:
			stats.Running++
		}
	}
	stats.Success = stats.NoChanges + stats.Changes

	return stats
}

func (r *CommentRenderer) renderStats(stats planStats) string {
	var parts []string

	if stats.Changes > 0 {
		parts = append(parts, fmt.Sprintf("üîÑ **%d** with changes", stats.Changes))
	}
	if stats.NoChanges > 0 {
		parts = append(parts, fmt.Sprintf("‚úÖ **%d** no changes", stats.NoChanges))
	}
	if stats.Failed > 0 {
		parts = append(parts, fmt.Sprintf("‚ùå **%d** failed", stats.Failed))
	}
	if stats.Running > 0 {
		parts = append(parts, fmt.Sprintf("üîÑ **%d** running", stats.Running))
	}
	if stats.Pending > 0 {
		parts = append(parts, fmt.Sprintf("‚è≥ **%d** pending", stats.Pending))
	}

	if len(parts) == 0 {
		return fmt.Sprintf("**%d** modules analyzed", stats.Total)
	}

	return fmt.Sprintf("**%d** modules: %s", stats.Total, strings.Join(parts, " | "))
}

func (r *CommentRenderer) groupByEnvironment(plans []ModulePlan) map[string][]ModulePlan {
	result := make(map[string][]ModulePlan)
	for i := range plans {
		env := plans[i].Environment
		if env == "" {
			env = "default"
		}
		result[env] = append(result[env], plans[i])
	}
	return result
}

func (r *CommentRenderer) sortedKeys(m map[string][]ModulePlan) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}

func (r *CommentRenderer) renderEnvironmentSection(env string, plans []ModulePlan) string {
	var sb strings.Builder

	// Environment header
	sb.WriteString(fmt.Sprintf("### üì¶ Environment: `%s`\n\n", env))

	// Sort plans by module ID
	sort.Slice(plans, func(i, j int) bool {
		return plans[i].ModuleID < plans[j].ModuleID
	})

	// Table header
	sb.WriteString("| Status | Module | Summary |\n")
	sb.WriteString("|:------:|--------|--------|\n")

	for i := range plans {
		sb.WriteString(r.renderPlanRow(&plans[i]))
	}

	// Expandable details for modules with changes or errors
	for i := range plans {
		if plans[i].Details != "" && (plans[i].Status == PlanStatusChanges || plans[i].Status == PlanStatusFailed) {
			sb.WriteString(r.renderExpandableDetails(&plans[i]))
		}
	}

	return sb.String()
}

func (r *CommentRenderer) renderPlanRow(p *ModulePlan) string {
	status := r.statusIcon(p.Status)
	module := fmt.Sprintf("`%s`", p.ModuleID)

	summary := p.Summary
	if p.Error != "" {
		summary = fmt.Sprintf("‚ö†Ô∏è %s", truncate(p.Error, maxErrorLength))
	}
	if summary == "" {
		summary = "-"
	}

	return fmt.Sprintf("| %s | %s | %s |\n", status, module, summary)
}

func (r *CommentRenderer) statusIcon(status PlanStatus) string {
	switch status {
	case PlanStatusSuccess, PlanStatusNoChanges:
		return "‚úÖ"
	case PlanStatusChanges:
		return "üîÑ"
	case PlanStatusFailed:
		return "‚ùå"
	case PlanStatusPending:
		return "‚è≥"
	case PlanStatusRunning:
		return "üîÑ"
	default:
		return "‚ùì"
	}
}

func (r *CommentRenderer) renderExpandableDetails(p *ModulePlan) string {
	var sb strings.Builder

	title := fmt.Sprintf("Details: %s", p.ModuleID)
	if p.Status == PlanStatusFailed {
		title = fmt.Sprintf("Error: %s", p.ModuleID)
	}

	sb.WriteString(fmt.Sprintf("\n<details>\n<summary>%s</summary>\n\n", title))
	sb.WriteString("```hcl\n")
	sb.WriteString(truncate(p.Details, maxDetailsLength))
	sb.WriteString("\n```\n")
	sb.WriteString("</details>\n")

	return sb.String()
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

// FindTerraCIComment finds an existing terraci comment in the notes
func FindTerraCIComment(notes []*gitlab.Note) *gitlab.Note {
	for _, note := range notes {
		if strings.Contains(note.Body, CommentMarker) {
			return note
		}
	}
	return nil
}
